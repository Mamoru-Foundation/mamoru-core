/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_MAMORU_CORE_C__
#define __RUST_MAMORU_CORE_C__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct FfiU256 FfiU256_t;

FfiU256_t * ffi_u256_new (
    char const * str_hex);

typedef struct FfiI256 FfiI256_t;

FfiI256_t * ffi_i256_new (
    char const * str_hex);


#include <stddef.h>
#include <stdint.h>

typedef struct FfiTransaction FfiTransaction_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_FfiTransaction {

    FfiTransaction_t const * ptr;

    size_t len;

} slice_ref_FfiTransaction_t;

typedef struct FfiHashMap FfiHashMap_t;

typedef struct FfiBlock FfiBlock_t;

FfiBlock_t * ffi_block_new (
    FfiU256_t const * block_index,
    uint64_t time,
    slice_ref_FfiTransaction_t transactions,
    FfiHashMap_t const * extra);

typedef struct FfiEvent FfiEvent_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_FfiEvent {

    FfiEvent_t const * ptr;

    size_t len;

} slice_ref_FfiEvent_t;

typedef struct FfiCallTrace FfiCallTrace_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_FfiCallTrace {

    FfiCallTrace_t const * ptr;

    size_t len;

} slice_ref_FfiCallTrace_t;

FfiTransaction_t * ffi_transaction_new (
    FfiU256_t const * block_index,
    FfiU256_t const * tx_index,
    uint64_t time,
    slice_ref_FfiEvent_t events,
    slice_ref_FfiCallTrace_t call_traces,
    FfiHashMap_t const * extra);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_uint8 {

    uint8_t const * ptr;

    size_t len;

} slice_ref_uint8_t;

FfiEvent_t * ffi_event_new (
    FfiU256_t const * block_index,
    FfiU256_t const * tx_index,
    FfiU256_t const * event_index,
    slice_ref_uint8_t event_id,
    FfiHashMap_t const * extra);

FfiCallTrace_t * ffi_call_trace_new (
    FfiU256_t const * block_index,
    FfiU256_t const * tx_index,
    FfiU256_t const * call_trace_index,
    slice_ref_FfiEvent_t events,
    FfiHashMap_t const * extra);

FfiHashMap_t * ffi_hash_map_new (void);

typedef struct FfiValue FfiValue_t;

/** \brief
 *  Drops `value` argument
 */
void ffi_hash_map_append (
    FfiHashMap_t * map,
    char const * key,
    FfiValue_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_i8_new (
    FfiI256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_i16_new (
    FfiI256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_i32_new (
    FfiI256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_i64_new (
    FfiI256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_i128_new (
    FfiI256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_i256_new (
    FfiI256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_u8_new (
    FfiU256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_u16_new (
    FfiU256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_u32_new (
    FfiU256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_u64_new (
    FfiU256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_u128_new (
    FfiU256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_u256_new (
    FfiU256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_object_new (
    FfiHashMap_t * value);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_uint8 {

    uint8_t * ptr;

    size_t len;

    size_t cap;

} Vec_uint8_t;

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_binary_new (
    Vec_uint8_t value);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_FfiValue {

    FfiValue_t * ptr;

    size_t len;

    size_t cap;

} Vec_FfiValue_t;

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_array_new (
    Vec_FfiValue_t value);


#include <stdbool.h>

bool check_matches (
    FfiTransaction_t const * transaction);


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __RUST_MAMORU_CORE_C__ */
