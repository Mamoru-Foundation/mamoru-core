/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_MAMORU_CORE_C__
#define __RUST_MAMORU_CORE_C__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct FfiU256 FfiU256_t;

FfiU256_t * ffi_u256_new (
    char const * str_hex);

typedef struct FfiI256 FfiI256_t;

FfiI256_t * ffi_i256_new (
    char const * str_hex);

typedef struct FfiList FfiList_t;

FfiList_t * ffi_list_events_new (void);

typedef struct FfiEvent FfiEvent_t;

/** \brief
 *  Drops `value` argument
 */
void ffi_list_events_append (
    FfiList_t * list,
    FfiEvent_t * value);

FfiList_t * ffi_list_call_traces_new (void);

typedef struct FfiCallTrace FfiCallTrace_t;

/** \brief
 *  Drops `value` argument
 */
void ffi_list_call_traces_append (
    FfiList_t * list,
    FfiCallTrace_t * value);

FfiList_t * ffi_list_transactions_new (void);

typedef struct FfiTransaction FfiTransaction_t;

/** \brief
 *  Drops `value` argument
 */
void ffi_list_transactions_append (
    FfiList_t * list,
    FfiTransaction_t * value);

FfiList_t * ffi_list_values_new (void);

typedef struct FfiValue FfiValue_t;

/** \brief
 *  Drops `value` argument
 */
void ffi_list_values_append (
    FfiList_t * list,
    FfiValue_t * value);


#include <stddef.h>
#include <stdint.h>

typedef struct FfiHashMap FfiHashMap_t;

typedef struct FfiBlock FfiBlock_t;

FfiBlock_t * ffi_block_new (
    FfiU256_t const * block_index,
    uint64_t time,
    FfiList_t const * transactions,
    FfiHashMap_t const * extra);

FfiTransaction_t * ffi_transaction_new (
    FfiU256_t const * block_index,
    FfiU256_t const * tx_index,
    uint64_t time,
    FfiList_t const * events,
    FfiList_t const * call_traces,
    FfiHashMap_t const * extra);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_uint8 {

    uint8_t const * ptr;

    size_t len;

} slice_ref_uint8_t;

FfiEvent_t * ffi_event_new (
    FfiU256_t const * block_index,
    FfiU256_t const * tx_index,
    FfiU256_t const * event_index,
    slice_ref_uint8_t event_id,
    FfiHashMap_t const * extra);

FfiCallTrace_t * ffi_call_trace_new (
    FfiU256_t const * block_index,
    FfiU256_t const * tx_index,
    FfiU256_t const * call_trace_index,
    FfiList_t const * events,
    FfiHashMap_t const * extra);

FfiHashMap_t * ffi_hash_map_new (void);

/** \brief
 *  Drops `value` argument
 */
void ffi_hash_map_append (
    FfiHashMap_t * map,
    char const * key,
    FfiValue_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_i8_new (
    FfiI256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_i16_new (
    FfiI256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_i32_new (
    FfiI256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_i64_new (
    FfiI256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_i128_new (
    FfiI256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_i256_new (
    FfiI256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_u8_new (
    FfiU256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_u16_new (
    FfiU256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_u32_new (
    FfiU256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_u64_new (
    FfiU256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_u128_new (
    FfiU256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_u256_new (
    FfiU256_t * value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_object_new (
    FfiHashMap_t * value);

FfiValue_t * ffi_value_binary_new (
    slice_ref_uint8_t value);

/** \brief
 *  Drops `value` argument
 */
FfiValue_t * ffi_value_array_new (
    FfiList_t * value);


#include <stdbool.h>

bool check_matches (
    FfiTransaction_t const * transaction);

void ffi_free_u256 (
    FfiU256_t * value);

void ffi_free_i256 (
    FfiI256_t * value);

void ffi_free_hash_map (
    FfiHashMap_t * value);

void ffi_free_list_transactions (
    FfiList_t * value);

void ffi_free_list_events (
    FfiList_t * value);

void ffi_free_list_call_traces (
    FfiList_t * value);

void ffi_free_block (
    FfiBlock_t * value);

void ffi_free_transaction (
    FfiTransaction_t * value);

void ffi_free_event (
    FfiEvent_t * value);

void ffi_free_call_trace (
    FfiCallTrace_t * value);


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __RUST_MAMORU_CORE_C__ */
