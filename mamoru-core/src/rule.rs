use crate::{BlockchainDataCtx, DataError};
use datafusion::arrow::json::writer::record_batches_to_json_rows;
use datafusion::dataframe::DataFrame;
use datafusion::sql::parser::{DFParser, Statement};
use datafusion::sql::planner::SqlToRel;
use datafusion::sql::sqlparser;
use serde_json::{Map, Value};
use std::collections::HashMap;

pub type VerifyCtxOutputs = Vec<Map<String, Value>>;

#[derive(Debug, Clone)]
pub struct VerifyCtx {
    /// Do blockchain data match the rule.
    pub matched: bool,

    /// Outputs generated by the rule expression.
    pub outputs: VerifyCtxOutputs,
}

#[derive(Clone, Debug)]
pub struct Rule {
    id: String,
    activate_since: i64,
    inactivate_since: i64,
    query: sqlparser::ast::Query,
}

impl Rule {
    pub fn new(
        id: String,
        activate_since: i64,
        inactivate_since: i64,
        expression: &str,
    ) -> Result<Self, DataError> {
        let query = Self::extract_query(expression)?;

        Ok(Rule {
            id,
            activate_since,
            inactivate_since,
            query,
        })
    }

    pub fn id(&self) -> String {
        self.id.clone()
    }

    pub async fn verify(&self, ctx: &BlockchainDataCtx) -> Result<VerifyCtx, DataError> {
        if !self.is_active(ctx.time().timestamp()) {
            return Ok(VerifyCtx {
                matched: false,
                outputs: vec![],
            });
        }

        let outputs = self.execute(ctx).await?;

        Ok(VerifyCtx {
            matched: !outputs.is_empty(),
            outputs,
        })
    }

    /// Executes the given query.
    /// Returns the result data as a list of json-serializable values
    async fn execute(&self, ctx: &BlockchainDataCtx) -> Result<VerifyCtxOutputs, DataError> {
        let state = ctx.session().state.clone();
        let provider = state.read().clone();

        let plan = SqlToRel::new(&provider)
            .query_to_plan(self.query.clone(), &mut HashMap::new())
            .map_err(DataError::PlanQuery)?;

        let data = DataFrame::new(state, &plan)
            .collect()
            .await
            .map_err(DataError::ExecuteQuery)?;

        let list = record_batches_to_json_rows(&data[..]).map_err(DataError::RecordBatchToJson)?;

        Ok(list)
    }

    /// Extracts query statements only, as we don't want
    /// someone to call INSERT/UPDATE/CREATE TABLE etc., in the virtual db.
    fn extract_query(expression: &str) -> Result<sqlparser::ast::Query, DataError> {
        let mut statements = DFParser::parse_sql(expression).map_err(DataError::ParseSql)?;

        if statements.len() != 1 {
            return Err(DataError::WrongStatementsNumber);
        }

        let statement = statements
            .pop_front()
            .expect("A single statement exists, as checked before.");

        // A workaround to extract an item from [`Box`]
        let extract_query = |statement: sqlparser::ast::Statement| match statement {
            sqlparser::ast::Statement::Query(query) => Some(*query),
            _ => None,
        };

        let query = match statement {
            Statement::Statement(sql_statement) => extract_query(*sql_statement),
            _ => None,
        };

        query.ok_or(DataError::UnsupportedStatement)
    }

    /// `inactivate_since` has more priority
    pub fn is_active(&self, time: i64) -> bool {
        let inactive = time >= self.inactivate_since;
        let active = time >= self.activate_since;

        if inactive {
            false
        } else {
            active
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn not_yet_active_rule_does_not_match() {
        let rule = rule(ACTIVE_SINCE, INACTIVE_SINCE);
        let is_active = rule.is_active(ACTIVE_SINCE - 1);

        assert!(!is_active);
    }

    #[test]
    fn already_inactive_rule_does_not_match() {
        let rule = rule(ACTIVE_SINCE, INACTIVE_SINCE);
        let is_active = rule.is_active(INACTIVE_SINCE);

        assert!(!is_active);
    }

    #[test]
    fn inactive_has_higher_priority() {
        // `inactive_since = 0` makes the rule always inactive,
        // regardless the `active_since` value
        let rule = rule(1, 0);
        let is_active = rule.is_active(2);

        assert!(!is_active);
    }

    #[test]
    fn active_rule_does_match() {
        let rule = rule(ACTIVE_SINCE, INACTIVE_SINCE);
        let is_active = rule.is_active(ACTIVE_SINCE);

        assert!(is_active);
    }

    const ACTIVE_SINCE: i64 = 10;
    const INACTIVE_SINCE: i64 = ACTIVE_SINCE + 10;

    fn rule(active_since: i64, inactive_since: i64) -> Rule {
        Rule::new(
            "test".to_string(),
            active_since,
            inactive_since,
            "SELECT * FROM dummy",
        )
        .unwrap()
    }
}
